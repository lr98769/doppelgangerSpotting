---
title: "The Doppelganger Effect in Biomedical Data sets"
output: html_notebook
---

# 3. Exploring the ALL (Acute Lymphocytic Leukemia) Datasets

## 0) Import packages

```{r Import & Install Packages, include=FALSE}
if (!("doppelgangerIdentifier" %in% installed.packages())){
  install.packages('devtools')
  library(devtools)
  install_github('lr98769/doppelgangerIdentifier')
}
library("doppelgangerIdentifier")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!("biomaRt" %in% installed.packages())){
  BiocManager::install("biomaRt")
}
library("biomaRt")
```

Some functions for pre-processing and analysis:
```{r}
# This function converts the probes to ensemble id
# df = df with the column "Probe"
# 
convertProbesToEnsemble <- function(df, affy_attribute){
  if (!exists("ensembl")){
  ensembl <<- useEnsembl(biomart = "ensembl", 
                    dataset = 'hsapiens_gene_ensembl')
  }
  if (!"Probe" %in% colnames(df)){
    print("The column 'Probe' is missing from df")
    return()
  }
  return_list = list()
  mapping_table =  select(ensembl, 
                          keys= df$Probe, 
                          columns= c(affy_attribute,
                                     "ensembl_gene_id"),
                          keytype= affy_attribute)
  return_list[["mapping_table"]] = mapping_table
  # Ensure the each affy attribute maps to only 1 ensemble id 
  # (the smallest one) 
  # (Ensure that affy->ensemble is a one-to-one mapping)
  mapping_table = mapping_table[
    order(mapping_table[[affy_attribute]],
          mapping_table[["ensembl_gene_id"]]),]
  mapping_table = mapping_table[!duplicated(
    mapping_table[[affy_attribute]]),]
  
  # Remove all probes with no corresponding ensemble id
  df = df[df$Probe %in% mapping_table[[affy_attribute]],]
  # Replace rownames with the ensemble gene id
  rownames(mapping_table) = mapping_table[[affy_attribute]]
  df$ensembl_ID = mapping_table[df$Probe,"ensembl_gene_id"]
  return_list[["before_dedup"]] = df
  df$Probe = NULL
  # ensure order of variables stay the same for checking purposes
  current_order = unique(df$ensembl_ID)
  # Get the median signal of probes with the same ensemble id
  df = aggregate(df[,-ncol(df)], by = list(df[,"ensembl_ID"]) , median)
  rownames(df) = df$Group.1
  df$Group.1 = NULL
  df = df[current_order, ]
  return_list[["returned_df"]] = df
  return(return_list)
}
# Integrates file loading, replacing probes with ensemble id and caching of cleaned_data
getDataFile<- function(filename, affy_attribute, batch_name){
  cleaned_filename = paste("cleaned_",filename, sep="")
  if (!file.exists(cleaned_filename)){
    temp_df = read.csv(filename)
    temp_df$PROT = NULL # Remove PROT column
    # Convert probes to ensemble ids
    conversion_results <<- convertProbesToEnsemble(
                                df = temp_df,
                                affy_attribute = affy_attribute)
    temp_df = conversion_results$returned_df
    # Add H to the end so that we can differentiate it later
    colnames(temp_df) = paste(colnames(temp_df), batch_name, sep = "_")
    write.csv(temp_df, cleaned_filename)
    return(temp_df)
  } else {
    temp_df = read.csv(cleaned_filename, row.names = 1)
    return(temp_df)
  }
}
# Generates meta data table from an existing dataframe (Assumes each row is a different patient)
getMetaDataDataframe <-function(df, batch_name){
  meta = data.frame(row.names = colnames(df))
  meta$Patient_ID = rownames(meta)
  meta$Batch = batch_name
  meta$Class = substr(meta$Patient_ID, 1, 3)
  return(meta)
}
# Difference between PPCC dfs
dfSetDifference <- function(df1, df2){
  setdifference = c()
  for (i in 1:nrow(df1)){
    if (!any(df2$Sample1 == df1[i, "Sample1"] & 
             df2$Sample2 == df1[i, "Sample2"])){
      setdifference = c(setdifference, i)
    }
  }
  return(df1[setdifference,])
}
getDoppelnNonDoppelSamples <- function(doppel_result, metadata, batchname){
  samples = unique(doppel_result$PPCC_df[doppel_result$PPCC_df$DoppelgangerLabel=="Doppelganger", "Sample1"])
  samples = c(samples, unique(doppel_result$PPCC_df[doppel_result$PPCC_df$DoppelgangerLabel=="Doppelganger", "Sample2"]))
  all_samples_of_batch = rownames(metadata[metadata$Batch==batchname,])
  doppel_samples = intersect(all_samples_of_batch, samples)
  non_doppel_samples = setdiff(all_samples_of_batch, doppel_samples)
  # Output in df form
  return_list = list(doppel_samples, non_doppel_samples)
  ## Compute maximum length
  max_length = max(sapply(return_list, length))
  ## Add NA values to list elements
  return_list = lapply(return_list, function(v) { 
    c(v, rep(NA, max_length-length(v)))
    })
  # Column bind them
  return_df = do.call(cbind, return_list)
  colnames(return_df) = c("Doppelganger Samples", "Non-Doppelganger Samples")
  return(return_df)
}

# Over sample the raw and meta data automatically
oversample_batch <- function(raw_data, meta_data, seed=2021){
  return_list = list()
  # get batch sizes
  batch_sizes = table(meta_data$Batch)
  # Get number of samples to over sample
  add_num_samples = max(batch_sizes) - min(batch_sizes)
  # Get batch to over sample
  min_batch = names(which.min(batch_sizes))
  # Get min_batch sample names
  min_batch_samples = rownames(meta_data[meta_data$Batch==min_batch, ])
  # Over sample some samples
  set.seed(seed)
  if (add_num_samples < length(min_batch_samples)){
    new_sample_names = sample(min_batch_samples, add_num_samples, 
                            replace = FALSE) 
  }
  else {
    print("Error: This function does not support oversampling of over twice the smaller batch's size")
    return()
  }
  
  new_samples_meta = meta_data[new_sample_names, ]
  rownames(new_samples_meta) = paste(rownames(new_samples_meta), "dup", sep="_")
  return_list[["meta_data"]] = as.data.frame(rbind(meta_data,new_samples_meta))
  
  new_samples_raw = raw_data[, new_sample_names]
  colnames(new_samples_raw) = paste(colnames(new_samples_raw), "dup", sep="_")
  return_list[["raw_data"]] = as.data.frame(cbind(raw_data,new_samples_raw))
  
  return(return_list)
}

# Removes added duplicate samples and sample pairs
remove_all_dup <-function(doppel_result){
  doppel_return = doppel_result
  # Get column names with "_dup"
  duplicates = grep('_dup', colnames(doppel_return$Batch_corrected), value=TRUE)
  doppel_return$Batch_corrected = doppel_return$Batch_corrected[, !(colnames(doppel_return$Batch_corrected) %in% duplicates)]
  doppel_return$PPCC_matrix = doppel_return$PPCC_matrix[, !(colnames(doppel_return$PPCC_matrix) %in% duplicates)]
  doppel_return$PPCC_matrix = doppel_return$PPCC_matrix[!(rownames(doppel_return$PPCC_matrix) %in% duplicates),]
  doppel_return$PPCC_df = doppel_return$PPCC_df[!(doppel_return$PPCC_df$Sample1 %in% duplicates) & !(doppel_return$PPCC_df$Sample2 %in% duplicates), ]
  return(doppel_return)
}
```


## 1) Importing the Datsets
AllenData
- 15 BCR
- 18 E2A

```{r}
all_a = getDataFile(filename = "data/Subtype-AllenData.csv",
                    affy_attribute = "affy_hg_u133a",
                    batch_name = "A")
all_a_meta = getMetaDataDataframe(df = all_a,
                                  batch_name = "A")
```

MaryData
- 15 BCR
- 27 E2A

```{r}
all_m = getDataFile(filename = "data/Subtype-MaryData.csv",
                    affy_attribute = "affy_hg_u95av2",
                    batch_name = "M")
all_m_meta = getMetaDataDataframe(df = all_m,
                                  batch_name = "M")
```

## 2) Finding Doppelgangers

### a) Within Allen Data

```{r}
doppel_all_a = getPPCCDoppelgangers(all_a, all_a_meta)
```

```{r}
visualisePPCCDoppelgangers(doppel_all_a)
```
48 Doppelgangers within Allen Data.

```{r}
table(doppel_all_a$PPCC_df$DoppelgangerLabel)
```

### b) Within Mary Data

```{r}
doppel_m = getPPCCDoppelgangers(all_m, all_m_meta)
```

```{r}
visualisePPCCDoppelgangers(doppel_m)
```

There are 114 Doppelgangers in Mary Data.

```{r}
table(doppel_m$PPCC_df$DoppelgangerLabel)
```

### c) Between Allen and Mary

```{r}
shared_variables_all =  intersect(
                          rownames(all_a),
                          rownames(all_m))
all = data.frame(cbind(all_a[shared_variables_all,],
                       all_m[shared_variables_all,]))
all_meta = data.frame(rbind(all_a_meta, all_m_meta))
doppel_am = getPPCCDoppelgangers(all, all_meta)
```
Only 6 Doppelgangers between AllenData and MaryData.

```{r}
table(doppel_am$PPCC_df$DoppelgangerLabel)
```

```{r}
doppel_am$PPCC_df[doppel_am$PPCC_df$DoppelgangerLabel=="Doppelganger",]
```
```{r}
doppel_am$cut_off
```

```{r}
visualisePPCCDoppelgangers(doppel_am)
```
## 3) Batch Imbalance on Doppelganger Identification

Since sva:Combat is used in the doppelgangerIdentifier and batch imbalance affects the efficacy of batch correction, we will now be exploring the impacts of batch imbalance on doppelgangerIdentifier's performance. 

AllenData and MaryData do not have the same sample size. To test the impact of batch imbalance, we test the case with imbalance (the previous result) and the case with no imbalance (oversampling of AllenData)

```{r}
table(all_meta$Batch)
```

### a) If we do not balance the batches before doppelganger identification

We identify 6 doppelgangers can seen in the previous section.

### b) If we balance the batches before we identify doppelgangers

We will now over sample AllenData

```{r}
oversample = oversample_batch(all, all_meta)
all_over = oversample$raw_data
all_meta_over = oversample$meta_data
table(all_meta_over$Class, all_meta_over$Batch)
```

```{r}
doppel_am_over = getPPCCDoppelgangers(all_over, all_meta_over)
```

Remove extra pairs
```{r}
doppel_am_over = remove_all_dup(doppel_am_over)
```

When batches are balanced, 6 doppelgangers were identified.

```{r}
table(doppel_am_over$PPCC_df$DoppelgangerLabel)
```

```{r}
dfSetDifference(
  doppel_am_over$PPCC_df
  [doppel_am_over$PPCC_df$DoppelgangerLabel=="Doppelganger",],
  doppel_am$PPCC_df
  [doppel_am$PPCC_df$DoppelgangerLabel=="Doppelganger",]
  )
```

```{r}
dfSetDifference(
  doppel_am$PPCC_df
  [doppel_am$PPCC_df$DoppelgangerLabel=="Doppelganger",],
  doppel_am_over$PPCC_df
  [doppel_am_over$PPCC_df$DoppelgangerLabel=="Doppelganger",]
  )
```


```{r}
visualisePPCCDoppelgangers(doppel_am_over)
```
```{r}
summary(doppel_am$PPCC_df$PPCC)
```

```{r}
summary(doppel_am_over$PPCC_df$PPCC)
```

When batches were balanced before doppelganger identification, PPCC decreased slightly. 

### c) Batch imbalance on batch correction efficacy

```{r}
if (!"ggfortify" %in% installed.packages()){
  install.packages("ggfortify")
}
library(ggfortify)
```

#### Before Batch Correction
```{r}
pca_res = prcomp(t(all), scale. = TRUE)
autoplot(x=1, y=2, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

```{r}
autoplot(x=2, y=3, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

#### With batch imbalance

```{r}
pca_res = prcomp(t(doppel_am$Batch_corrected), scale. = TRUE)
autoplot(x=1, y=2, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

```{r}
autoplot(x=2, y=3, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

#### Without batch imbalance

```{r}
pca_res = prcomp(t(doppel_am_over$Batch_corrected), scale. = TRUE)
autoplot(x=1, y=2, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

```{r}
autoplot(x=2, y=3, pca_res, data = all_meta, colour = 'Class', shape="Batch")
```

Output information from above into excel for planning purposes.

```{r}
if (!"openxlsx" %in% installed.packages()){
  install.packages("openxlsx")
}
library(openxlsx)
wb = createWorkbook()
addWorksheet(wb, "MetaData")
addWorksheet(wb, "DoppelgangerPairs")
addWorksheet(wb, "ExtraPairs_Bal-Unbal")
addWorksheet(wb, "ExtraPairs_Unbal-Bal")
addWorksheet(wb, "DoppelgangerSamplesA")
addWorksheet(wb, "DoppelgangerSamplesM")

writeData(wb, 1, all_meta)
writeData(wb, 2, 
          doppel_am_over$PPCC_df
          [doppel_am_over$PPCC_df$DoppelgangerLabel=="Doppelganger",])

writeData(wb, 3, dfSetDifference(
  doppel_am_over$PPCC_df
  [doppel_am_over$PPCC_df$DoppelgangerLabel=="Doppelganger",],
  doppel_am$PPCC_df
  [doppel_am$PPCC_df$DoppelgangerLabel=="Doppelganger",]
  )
)
writeData(wb, 4, dfSetDifference(
  doppel_am$PPCC_df
  [doppel_am$PPCC_df$DoppelgangerLabel=="Doppelganger",],
  doppel_am_over$PPCC_df
  [doppel_am_over$PPCC_df$DoppelgangerLabel=="Doppelganger",]
  )
)
writeData(wb, 5, getDoppelnNonDoppelSamples(
  doppel_result = doppel_am_over,
  metadata = all_meta,
  batchname = "A"))
writeData(wb, 6, getDoppelnNonDoppelSamples(
  doppel_result = doppel_am_over,
  metadata = all_meta,
  batchname = "M"))
saveWorkbook(wb, file = "output/all_planning.xlsx", overwrite = TRUE)
```

## 4) Testing the doppelganger effect of identified doppelgangers

```{r}
veri_results_all = verifyDoppelgangers(
  experimentPlanFilename = "cleaned_data/all_experiment_plan.csv",
  raw_data = doppel_am$Batch_corrected,
  meta_data = all_meta,
  do.batch.corr = FALSE)
```

```{r fig.width=10, fig.height=5}
originalTrainValidNames =  c("Doppel_0", "Doppel_1_Unbal", "Doppel_1", "Doppel_2","Doppel_3","Doppel_4", "Doppel_5", "Neg_Con", "Pos_Con_5")

newTrainValidNames =  c("0 Doppel", "1 Doppel Unbal","1 Doppel", "2 Doppel","3 Doppel","4 Doppel", "5 Doppel", "Neg Con", "Pos Con 5")

visualiseVerificationResults(veri_results_all,
                originalTrainValidNames = originalTrainValidNames,
                newTrainValidNames = newTrainValidNames)
```
## Extra Findings

What happens if we do not verify using batch balanced data.

```{r fig.width=10, fig.height=5}
veri_results_all_extra = verifyDoppelgangers(
  experimentPlanFilename = "cleaned_data/all_experiment_plan.csv",
  raw_data = all,
  meta_data = all_meta)
originalTrainValidNames =  c("Doppel_0", "Doppel_1_Unbal", "Doppel_1", "Doppel_2","Doppel_3","Doppel_4", "Doppel_5", "Neg_Con", "Pos_Con_5")

newTrainValidNames =  c("0 Doppel", "1 Doppel Unbal","1 Doppel", "2 Doppel","3 Doppel","4 Doppel", "5 Doppel", "Neg Con", "Pos Con 5")

visualiseVerificationResults(veri_results_all_extra,
                originalTrainValidNames = originalTrainValidNames,
                newTrainValidNames = newTrainValidNames)
```
## Arrange plots

```{r fig.height=4, fig.width=8}
if (!"ggpubr" %in% installed.packages()){
  install.packages("ggpubr")
}
library(ggpubr)

all_plot1 = ggarrange(
          ggpar(visualisePPCCDoppelgangers(doppel_am) +
            coord_cartesian(ylim = c(0.75, 1)),
            title="Unbalanced Batches"), 
          ggpar(visualisePPCCDoppelgangers(doppel_am_over) +
            coord_cartesian(ylim = c(0.75, 1)),
            title="Balanced Batches")+ 
          rremove("ylab") +
          rremove("y.ticks")+
          rremove("y.text"), 
          align='h', 
          labels=c('A', 'B'),
          common.legend = T,
          legend = "bottom"
          )
all_plot1 = annotate_figure(all_plot1, 
                            top = text_grob("ALL PPCC Distribution & Doppelganger identification", 
               color = "black",
               face = "bold", 
               size = 18))
all_plot1
ggsave(filename = "./images/all_PPCC.tiff", width = 8, height = 4, device='tiff')
```
```{r fig.width=11, fig.height=5}
originalTrainValidNames =  c("Doppel_0", "Doppel_1_Unbal", "Doppel_1", "Doppel_2","Doppel_3","Doppel_4", "Doppel_5", "Neg_Con", "Pos_Con_5")

newTrainValidNames =  c("0 Doppel", "1 Doppel\n (Only In\n Unbalanced)","1 Doppel\n (Only In\n Balanced)", "2 Doppel","3 Doppel","4 Doppel", "5 Doppel", "Neg Con", "5 Pos Con")

all_plot2 = visualiseVerificationResults(veri_results_all,
                originalTrainValidNames = originalTrainValidNames,
                newTrainValidNames = newTrainValidNames)
all_plot2 = ggpar(all_plot2, title="Validation Accuracy of KNN Models (ALL)") +
  font("title", size = 18, color = "black", face = "bold") +
  font("xlab", size = 14, color = "black") +
  font("xylab", size = 14, color = "black") +
  font("xy.text", size = 11, color = "black") +
  font("legend.title", size = 14, color = "black") +
  font("legend.text", size = 11, color = "black")
all_plot2
ggsave(filename = "./images/all_veri.tiff", width = 11, height = 5, device='tiff')
```

